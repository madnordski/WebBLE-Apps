<!-- ServoTest
     This is used to test javascript touch elements for controlling
     motors.
     J. King 31 Oct 2024

     This project is being used to help develop the interface for a
     project that might use servos, dc motors, stepping motors or a
     combination of these.  While we await arrival of the hardware we
     need to conduct our physical experiments, we can make progress by
     tinkering with the user interface.

     We will use an ESP32-C3 to control the motors. Preliminarily an
     XIAO ESP32-C3 is being used.  The communication between the
     android interface and the ESP32-C3 will be Bluetooth Low Energy
     (BLE).  On the phone we will use WebBLE.  This file represents
     the implementation of the WebBLE interface which runs on Android
     using a Web Browser.

     NB: The WebBLE security model requires that is script run of
     https which we accomplish be launching from our GITHUB
     page. Alternatively, (according to documentation) it can be
     loaded from the phone it runs on.  However, editing and debuging
     javascript on a phone is very limited.  Using a browser on our
     desktop computer we can use the full javascript debugger in
     Chrome.

To connect the Android phone to Chrome running our desktop:

1. Connect the phone to the computer over USB.

2. Under developer options on the phone enable USB debuging.

3. If USB debugging is already enabled, disable it, pause and enable
   it again before proceeding. If you don't have developer options,
   google how to enable them.

4. Now open the browser on the computer to chrome://inspect/#devices
   (it will take minutes before a connection opens that shows the web
   pages open on the phone with a link to inspect)

5. While waiting for the phone to show up, a list of targets will
   appear. Just leave it alone, eventually your phone will show up
   in this list with an inspect link for the web page you want to debug.

6. Also while waiting, on the phone load the web page you want to
   debug on your browser.  In this case, it is
   https://madnordski.github.io/WebBLE-Apps/ServoTest.html. (https is
   required, which is why we edit the github file)

7. Eventually (5-10 minutes), a link to INSPECT the web page you're
   debugging will appear in your computer browser.  Click the inspect
   link.  You did leave this page and your phone alone this entire
   time?

8. Once this is established, try not do anything that will crash or
   close the browser because when that happens you'll need to go back
   to step 1.  WebBLE will crash the browser window if reloaded while
   connected.

9. You can now reload and debug the app running on the phone as if
   it was running in your computers browser.

     Parts of this code was based on the work of Rui Santos.
     Find his project details at
     https://RandomNerdTutorials.com/esp32-web-bluetooth/

  Copyright (c) 2024, Joseph J. King, PhD

  Permission is hereby granted, free of charge, for educational
  purposes. Use of the this software for commercial purposes is
  strictly prohibited.  The above copyright notice and this permission
  notice shall be included in all copies or substantial portions of
  the Software.

-->

<!DOCTYPE html>
<html>
<head>
  <title>ServoTest Web BLE App</title>
  <!-- Use the width of the phone screen.
  For this project, scrolling will not be possible so we we will keep
  the elements to a minimum. -->
  
    <meta name="viewport" content="width=device-width,
				   initial-scale=1">
    <!-- we created a funky web icon even though android doesn't show it -->
    <link rel="icon" type="image/png" href="lionel.png">
    <style>

      /* The dot is our main interface object -- it controls two
      motors giving us X, Y movement.  Use it like virtual track ball
      */

      .dot {
        height: 300px;
        width: 300px;
        background-color: #bbb;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
      }

      /* Mostly just for testing communication, we have a RED LED
      connected. This dot goes from gray to red when illuminated */
      
      .redled {
        height: 20px;
        width: 20px;
        background-color: #b00;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
        text-align: center;
        padding: 15px;
      }

      /* The GREEN LED indicates connection status.  It's gray when
      disconnected and green when not. */
      
      .grnled {
        height: 20px;
        width: 20px;
        background-color: #0b0;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
        padding: 15px;
      }

      /* We use this class for any LED that should be off */
      
      .gryled {
        height: 20px;
        width: 20px;
        background-color: #bbb;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
        padding: 15px;
      }

      td {
	  padding: 7px;
	  text-align: center;
      }
      
    </style>
</head>
<body>
  <h1 align="center">ServoTest</h1>
  <p align="center">

    <!-- Add guide lines to the motor control DOT.  This will help us
    when we want to move just one motor -->
    
    <span class="dot"><img src="lines.png" valign="center"></span>
  </p>
  <p align="center">

  <!-- probably don't need this table but keep the contents (i.e. spans) -->
  <table align="center">
    <tr><td>
	<input type="range" min="1" max="10" value=5 id="xspeed"
	       oninput="xspdValue.innerHTML=this.value;"
	       onchange="spdChange(0, this.value);">
      </td>
      <td>X-axis Speed: <span id="xspeed_value"></span>
      </td>
    </tr>
    <tr><td>
	<input type="range" min="1" max="10" value=5 id="yspeed"
	       oninput="yspdValue.innerHTML=this.value;"
	       onchange="spdChange(1, this.value);">
      </td>
      <td>Y-axis Speed: <span id="yspeed_value"></span>
      </td>
    </tr>
    
    <tr><td><span class="grnled" id="gled"></span></td>
      <td><span class="redled" id="rled"></span></td>
    </tr>
    <tr><td>Connect</td><td>Red LED</td></tr>    
  </table>
  <p align="center" id="servo_status">Servos Stopped</p>
</body>
<!-- ' -->

<script>
// we should try to connect when the page is loaded
// we should already know the name of server
// since the esp32 doesn't give up the connection, can't we just restore
//   the connection we had before the page was reloaded?

// Shorthand for document elements
const onButton = document.getElementById('onButton');
const offButton = document.getElementById('offButton');
const retrievedValue = document.getElementById('valueContainer');
const timestampContainer = document.getElementById('timestamp');
const redLED = document.getElementById('rled');
const grnLED = document.getElementById('gled');
const xspdSlider = document.getElementById('xspeed');
const xspdValue = document.getElementById('xspeed_value');
const yspdSlider = document.getElementById('yspeed');
const yspdValue = document.getElementById('yspeed_value');
const servoStatus = document.getElementById('servo_status');

//Define BLE Device Specs -- change these
var deviceName ='ServoTest';
var bleService = '75f29868-d8a4-452c-a78b-1f698ee6ab2b';
var ledCharacteristic = '19b10002-e8f2-537e-4f6c-d104768a1214';
var sensorCharacteristic = '1a476625-3aae-4ab4-a1a7-0c9e1f5c97e0';
var servo1Characteristic = '99819a8b-59cc-4174-beee-fcc74b02fc5b';
var controlSthik = '05ca6ae0-6810-4dc0-9f00-424d9b06261b';

//Global Variables to Handle Bluetooth
var bleServer;
var bleServiceFound;
var sensorCharacteristicFound;
var servo1OpInProgress = false;
var ledState = "on";

// **** EVENT LISTENERS ***

// toggle the Red LED
redLED.addEventListener('click', (event) => toggleRedLED());

// use the green LED to connect and disconnect the device
grnLED.addEventListener('click', (event) => {
    if ( isWebBluetoothEnabled() ) {
	// connect or disconnect
	if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	    if (bleServer && bleServer.connected) {
		if (sensorCharacteristicFound) {
		    sensorCharacteristicFound.stopNotifications()
		}
	    }
	    // disconnect by resetting the ESP32
	    writeOnControl("DIE");
	    sleep(100);
	    initialValues();
	}
	else {
	    // connect
	    connectToDevice();
	}
    }
});

function spdChange(axis, value) {
    if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	writeOnControl("SPEED " + axis + " " + value);
	console.log(value);
	if ( axis == 0 )
	    xspdValue.innerHTML = value;
	else
	    yspdValue.innerHTML = value;
    }
    else {
	alert("Not connected.");
    }
}

// **** Function definitions ***

// Check if BLE is available in your Browser
function isWebBluetoothEnabled() {
    if (!navigator.bluetooth) {
        console.log("Web Bluetooth API is not available in this browser!");
        window.alert("Web Bluetooth API is not available in this browser!");
    }
    console.log('Web Bluetooth API supported in this browser.');
    return true
}

// Connect to BLE Device and Enable Notifications
function oldConnectToDevice(){
    console.log('Initializing Bluetooth...');
    navigator.bluetooth.requestDevice({
        filters: [{name: deviceName}],
        optionalServices: [bleService]
    })
    // act on the Promise object returned
        .then(device => {
            console.log('Device Selected:', device.name);
	    grnLED.className = "grnled";
            device.addEventListener('gattservicedisconnected', onDisconnected);
            return device.gatt.connect();
        })
        .then(gattServer =>{
            bleServer = gattServer;
            console.log("Connected to GATT Server");
            return bleServer.getPrimaryService(bleService);
        })
        .then(service => {
            bleServiceFound = service;
            console.log("Service discovered:", service.uuid);
            return service.getCharacteristic(sensorCharacteristic);
        })
        .then(characteristic => {
            console.log("Characteristic discovered:", characteristic.uuid);
            sensorCharacteristicFound = characteristic;
            characteristic.addEventListener('characteristicvaluechanged',
					    handleCharacteristicChange);
            characteristic.startNotifications();
            console.log("Notifications Started.");
            return characteristic.readValue();
        })
        //.then(value => {
        //    console.log("Read value: ", value);
        //    const decodedValue = new TextDecoder().decode(value);
        //    console.log("Decoded value: ", decodedValue);
        //    retrievedValue.innerHTML = decodedValue;
        //})
        .catch(error => {
            console.log('Error: ', error);
        })
}

function onDisconnected(event){
    console.log('Device Disconnected:', event.target.device.name);
    grnLED.className = "gryled";
    connectToDevice();
}

function handleShtikChange(event){
    console.log(event.target);
    const newValueReceived = new TextDecoder().decode(event.target.value);
    console.log("Notification: ", newValueReceived);
    servoStatus.innerHTML = newValueReceived;
}

/* toggleRedLED
   Send the command to toggle the Red LED to the ESP32 using BLE Write.
   NB: toggle takes place after the write and is written next call.
*/

function toggleRedLED() {
    if (bleServer && bleServer.connected) {
        bleServiceFound.getCharacteristic(ledCharacteristic)
            .then(characteristic => {
                console.log("Found the LED characteristic: ", characteristic.uuid);
                const data = new Uint8Array(Array.from(ledState, char => char.charCodeAt(0)));
                return characteristic.writeValue(data);
            })
            .then(() => {
                console.log("Value written to LEDcharacteristic:", ledState);
		if ( ledState == "on" ) {
		    redLED.className = "redled";
		    ledState = "off";
		}
		else {
		    redLED.className = "gryled";
		    ledState = "on";
		}
            })
            .catch(error => {
                console.error("Error writing to the LED characteristic: ", error);
            });
    } else {
        console.error ("Bluetooth is not connected. Cannot write to characteristic.")
        window.alert("Bluetooth is not connected. Cannot write to characteristic. \n Connect to BLE first!")
    }
}

async function writeOnControl(value) {
    if ( bleServer && bleServer.connected ) {
	try {
	    await bleServiceFound.getCharacteristic(controlSthik)
		.then(characteristic => {
		    const data = new Uint8Array(Array.from(value, char => char.charCodeAt(0)));
		    return characteristic.writeValue(data);
		});
	}
	catch (error) {
	    if ( error.name === 'NetworkError'
	       || error.name === 'NotSupportedError' ) { // if busy, try again
		console.log("busy, trying again");
		await delay(50);
		return writeOnControl(value);
	    }
	    else {
                console.error("Error writing to the Servo1 characteristic: ", error);
            }
	}
    }
    else {
	console.error("Bluetooth is not connected!");
    }
}

async function writeOnServo1Characteristic(value){
    if (bleServer && bleServer.connected) {
	try {
	    // use try/catch to make sure this completes -- retry
            await bleServiceFound.getCharacteristic(servo1Characteristic)
		.then(characteristic => {
                    const data = new Uint8Array(Array.from(value, char => char.charCodeAt(0)));
		    return characteristic.writeValue(data);
		});
	}
	catch (error) {
	    if ( false && error.name === 'NetworkError'
	       || error.name === 'NotSupportedError' ) { // if busy, try again
		console.log("busy, trying again");
		await delay(50);
		return writeOnServo1Characteristic(value);
	    }
	    else {
                console.error("Error writing to the Servo1 characteristic: ", error);
            }
	}
    } else {
        console.error ("Bluetooth is not connected. Cannot write to characteristic.")
        window.alert("Bluetooth is not connected. Cannot write to characteristic. \n Connect to BLE first!")
    }
}

function getDateTime() {
    var currentdate = new Date();
    var day = ("00" + currentdate.getDate()).slice(-2); // Convert day to string and slice
    var month = ("00" + (currentdate.getMonth() + 1)).slice(-2);
    var year = currentdate.getFullYear();
    var hours = ("00" + currentdate.getHours()).slice(-2);
    var minutes = ("00" + currentdate.getMinutes()).slice(-2);
    var seconds = ("00" + currentdate.getSeconds()).slice(-2);
    
    var datetime = day + "/" + month + "/" + year + " at " + hours + ":" + minutes + ":" + seconds;
    return datetime;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function sleep(milliseconds) {
    var start = new Date().getTime();
    while ( true ) {
	if ((new Date().getTime() - start) > milliseconds){
	    break;
	}
    }
}

let lastDX, lastDY;  
let lastX, lastY;
const fuzz = 20; // reduces the resolution of the touch area

document.querySelector('.dot').addEventListener('touchstart',
						TStart, {passive: false});
document.querySelector('.dot').addEventListener('touchend',
						TStart, {passive: false});
document.querySelector('.dot').addEventListener('touchmove',
						TStart, {passive: false});
function TStart(ev) {
    ev.preventDefault();
    console.log(ev.touches, ev.type);
    if ( ev.type == 'touchstart' ) { // reset our starting point
	// everything is relative to that
	lastX = Math.floor(ev.touches[0].clientX / fuzz);
	lastY = Math.floor(ev.touches[0].clientY / fuzz);
	writeOnControl("START");
	getServoStatus();
	console.log("START");
    }
    else if ( ev.type == 'touchmove' ) {
	let dX = 0;
	let dY = 0;
	let x = Math.floor(ev.touches[0].clientX / fuzz);
	let y = Math.floor(ev.touches[0].clientY / fuzz);

	if ( x != lastX )
	    dX = x > lastX ? 1 : -1;
	if ( y != lastY )
	    dY = y > lastY ? 1 : -1;

	if ( dX != lastDX || dY != lastDY ) {
	    var msg = dX.toString() + " " + dY.toString();
	    writeOnServo1Characteristic(msg);
	    lastDX = dX;
	    lastDY = dY;
	    lastX = x;
	    lastY = y;
	    console.log("sent " + msg);
	    getServoStatus();
	}
    }
    else if ( ev.type == 'touchend' ) {
	console.log("STOP");
	delay(50);
	writeOnControl("STOP");
	console.log("Stop exit");
	sleep(100);
	getServoStatus();
    }
}

// start things off by connecting to the ESP32 over BLE
var bluetoothDevice;

async function connectToDevice() {
    if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	console.log("Already connected.");
	return;
    }
    try {
	await navigator.bluetooth.requestDevice({
	    filters: [{name: deviceName}],
	    optionalServices: [bleService]
	})
	// act on the promise object returned
	    .then(device => {
		console.log('Got device:', device.name);
		grnLED.className = 'grnled';
		device.addEventListener('gattservicedisconnected',
					onDisconnected);
		bluetoothDevice = device;
		return device.gatt.connect();
	    })
	    .then(gattServer => {
		bleServer = gattServer;
		console.log("GATT Server connected.");
		return bleServer.getPrimaryService(bleService);
	    })
	    .then(service => {
		bleServiceFound = service;
		console.log('Service discovered:', service.uuid);
		return service.getCharacteristic(sensorCharacteristic);
	    })
	    .then(characteristic => {
		sensorCharacteristicFound = characteristic;
		characteristic.addEventListener('characteristvaluechanged',
						handleShtikChange);
		sleep(200);
		characteristic.startNotifications();
		console.log("Notification starts.");
		sleep(100);
		return characteristic.readValue();
	    })
            .then(value => {
		const decodedValue = new TextDecoder().decode(value);
		console.log("Decoded value: ", decodedValue);
		servoStatus.innerHTML = decodedValue;
            })
	    .catch(error => {
		console.log('Error: ', error);
	    });
    }
    catch (error) {
	console.error('Connection error:', error);
    }
}

window.addEventListener('beforeunload', () => {
    disconnectDevice();
});

window.onload = initialValues;
function initialValues() {
    // led state
    ledState = "on";
    redLED.className = "gryled";
    grnLED.className = "gryled";
    
    // initial slider states
    xspdValue.innerHTML = "5";
    yspdValue.innerHTML = "5";
    xspdSlider.value = 5;
    yspdSlider.value = 5;
    servoStatus.innerHTML = "disconnected";
    //setInterval(getServoStatus, 5000);
}

function getServoStatus() {
    if ( bleServer && bleServer.connected ) {
	if ( sensorCharacteristicFound ) {
	    sensorCharacteristicFound.readValue()
		.then(v => {
		    const value = new TextDecoder().decode(v);
		    console.log("Servo Status Read: ", value);
		    servoStatus.innerHTML = value;
		});
	}
    }
}

function disconnectDevice() {
    console.log("Disconnect Device.");
    if (bleServer && bleServer.connected) {
        if (sensorCharacteristicFound) {
            sensorCharacteristicFound.stopNotifications()
                .then(() => {
                    console.log("Notifications Stopped");
                    return bleServer.disconnect();
                })
                .then(() => {
                    console.log("Device Disconnected");
		    
                })
                .catch(error => {
                    console.log("An error occurred:", error);
                });
        } else {
            console.log("No characteristic found to disconnect.");
        }
    } else {
        // Throw an error if Bluetooth is not connected
        console.error("Bluetooth is not connected.");
        window.alert("Bluetooth is not connected.")
    }
}

</script>

</html>

