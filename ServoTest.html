<!-- ServoTest
     This is used to test javascript touch elements for controlling
     motors.
     J. King 31 Oct 2024

     This project is being used to help develop the interface for a
     project that might use servos, dc motors, stepping motors or a
     combination of these.  While we await arrival of the hardware we
     need to conduct our physical experiments, we can make progress by
     tinkering with the user interface.

     We will use an ESP32-C3 to control the motors. Preliminarily an
     XIAO ESP32-C3 is being used.  The communication between the
     android interface and the ESP32-C3 will be Bluetooth Low Energy
     (BLE).  On the phone we will use WebBLE.  This file represents
     the implementation of the WebBLE interface which runs on Android
     using a Web Browser.

     NB: The WebBLE security model requires that thiis script run over
     https, which we accomplish by launching it from our GITHUB
     page. Alternatively, (according to documentation) it can be
     loaded from the phone it runs on.  However, editing and debuging
     javascript on a phone is very limited.  Using a browser on our
     desktop computer allows the use the full javascript debugger in
     Chrome.

     For the most part, we call BLE Characteristics, Aspects because it
     sounds better and is easier to type.

To connect the Android phone to Chrome running on our desktop:

1. Connect the phone to the computer over USB.

2. Under developer options on the phone enable USB debuging.

3. If USB debugging is already enabled, disable it, pause and enable
   it again before proceeding. If you don't have developer options,
   google how to enable them.

4. Now open the browser on the computer to chrome://inspect/#devices
   (it will take minutes before a connection opens that shows the web
   pages open on the phone with a link to inspect - seriously, make tea)

5. While waiting for the phone to show up, a list of targets will
   appear. Just leave it alone, eventually your phone will show up
   in this list with an inspect link for the web page you want to debug.

6. Also while waiting, on the phone load the web page you want to
   debug on your browser.  In this case, it is
   https://madnordski.github.io/WebBLE-Apps/ServoTest.html. (https is
   required, which is why we run using the github file)

7. Eventually (5-10 minutes?), a link to INSPECT the web page you're
   debugging will appear in your computer browser.  Click the inspect
   link.  You did leave this page and your phone alone this entire
   time?

8. Once this is established, try not do anything that will crash or
   close the browser because when that happens you'll need to go back
   to step 1.  WebBLE will crash the browser window if reloaded while
   connected.

9. You can now reload and debug the app running on the phone as if
   it was running in your computers browser.

     Parts of this code was based on the work of Rui Santos.
     Find his project details at
     https://RandomNerdTutorials.com/esp32-web-bluetooth/

  Copyright (c) 2024, Joseph J. King, PhD

  Permission is hereby granted, free of charge, for educational
  purposes. Use of the this software for commercial purposes is
  strictly prohibited.  The above copyright notice and this permission
  notice shall be included in all copies or substantial portions of
  the Software.

-->

<!DOCTYPE html>
<html>
<head>
  <title>ServoTest Web BLE App</title>
  <!-- Use the width of the phone screen.
  For this project, scrolling will not be possible so we we will keep
  the elements to a minimum. -->
  
    <meta name="viewport" content="width=device-width,
				   initial-scale=1">
    <!-- we created a funky web icon even though android doesn't show it -->
    <link rel="icon" type="image/png" href="lionel.png">
    <style>

      /* The dot is our main interface object -- it controls two
      motors giving us X, Y movement.  Use it like virtual track ball
      */

      .dot {
        height: 300px;
        width: 300px;
        background-color: #bbb;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
      }

      /* Mostly just for testing communication, we have a RED LED
      connected. This dot goes from gray to red when illuminated */
      
      .redled {
        height: 20px;
        width: 20px;
        background-color: #b00;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
        text-align: center;
        padding: 15px;
      }

      /* The GREEN LED indicates connection status.  It's gray when
      disconnected and green when not. */
      
      .grnled {
        height: 20px;
        width: 20px;
        background-color: #0b0;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
        padding: 15px;
      }

      /* We use this class for any LED that should be off */
      
      .gryled {
        height: 20px;
        width: 20px;
        background-color: #bbb;
        border-radius: 50%;
        display: inline-block;
	margin: auto;
	text-align: center;
        padding: 15px;
      }

      td {
	  padding: 4px;
	  text-align: center;
      }
      
    </style>
</head>
<body>
  <h1 align="center">ServoTest</h1>
  <p align="center">

    <!-- Add guide lines to the motor control DOT.  This will help us
    when we want to move just one motor -->
    
    <span class="dot"><img src="lines.png" valign="center"></span>
  </p>
  <p align="center">

    <!-- keep things tidy and simple
         Speed settings, connect/disconnect button and LED button -->
    
  <table align="center">
    <tr><td>
	<input type="range" min="1" max="10" value=5 id="xspeed"
	       oninput="xspdValue.innerHTML=this.value;"
	       onchange="spdChange(0, this.value);">
      </td>
      <td>X-axis Speed: <span id="xspeed_value"></span>
      </td>
    </tr>
    <tr><td>
	<input type="range" min="1" max="10" value=5 id="yspeed"
	       oninput="yspdValue.innerHTML=this.value;"
	       onchange="spdChange(1, this.value);">
      </td>
      <td>Y-axis Speed: <span id="yspeed_value"></span>
      </td>
    </tr>
    
    <tr><td><span class="grnled" id="gled"></span></td>
      <td><span class="redled" id="rled"></span></td>
    </tr>
    <tr><td>Connect</td><td>Red LED</td></tr>    
  </table>
  
  <!-- status line -->
  <p align="center" id="servo_status">Servos Stopped</p>
</body>
<!--  -->

<script>
// To connect to WebBLE user interaction is required.
// This script is dedicated to one server name or the connection
// choice will be limited to one.

// Disconnecting is accomplished by rebooting the ESP32.  This ensures
// a complete reset and makes debugging easier by allowing for
// repeated connects and disconnects.

// Shorthand for document elements
const redLED = document.getElementById('rled');
const grnLED = document.getElementById('gled');
const xspdSlider = document.getElementById('xspeed');
const xspdValue = document.getElementById('xspeed_value');
const yspdSlider = document.getElementById('yspeed');
const yspdValue = document.getElementById('yspeed_value');
const servoStatus = document.getElementById('servo_status');

// Unique Id's for our characteristics (aka aspects)
const deviceName ='ServoTest';
const bleService = '75f29868-d8a4-452c-a78b-1f698ee6ab2b';
const ledAspect = '19b10002-e8f2-537e-4f6c-d104768a1214';
const statusAspect = '1a476625-3aae-4ab4-a1a7-0c9e1f5c97e0';
const servoAspect = '99819a8b-59cc-4174-beee-fcc74b02fc5b';
const controlAspect = '05ca6ae0-6810-4dc0-9f00-424d9b06261b';

// Global Variables to Handle Bluetooth and other states
let bleServer;
let bleServiceFound;
let activeStatusAspect;
let servoBusy = false;
let ledState = "on";
let enableUpdates = false;

// **** EVENT LISTENERS ***

// toggle the Red LED
redLED.addEventListener('click', (event) => toggleRedLED());

// use the green LED to connect and disconnect the device
grnLED.addEventListener('click', (event) => {
    if ( isWebBluetoothEnabled() ) {
	// connect or disconnect
	if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	    // we are connected so disconnect
	    if (bleServer && bleServer.connected) {
		if (activeStatusAspect) {
		    activeStatusAspect.stopNotifications()
		}
	    }
	    // disconnect by resetting the ESP32
	    writeOnControl("DIE");
	    sleep(100);
	    initialValues();
	}
	else {
	    // not connected so we connect
	    connectToDevice();
	}
    }
});

// **** Function definitions ***

// Command to the ESP32 to change the servo motor speed.
// These are 360 degree servos so we get to control speed and
// direction but not degree position.

function spdChange(axis, value) {
    if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	writeOnControl("SPEED " + axis + " " + value);
	console.log(value);
	if ( axis == 0 )
	    xspdValue.innerHTML = value;
	else
	    yspdValue.innerHTML = value;
    }
    else {
	alert("Not connected.");
    }
}


/* Conditions must be right for WebBLE to work.
  1. ESP32 running BLE.
  2. This web page loaded in a Chrome or Chromium browser.
  3. Typically, the Chrome browser will be running on an Android phone
  for convenient use. NB: a touch screen is required. The iPhone is
  not supported.
  4. The web page must be loaded over https (not just http). The
  easiest way to us regular folks to do this is by hosting on a GIT
  hub page.  See Web Hosting options at github.com.

  At the end of day, this function will tell us if all of these
  conditions are met except one.  You can load this page on a computer
  without a touch screen, the app will run but you won't be able to
  move the motors.
  
*/

function isWebBluetoothEnabled() {
    if ( !navigator.bluetooth ) {
        console.log("Web Bluetooth API is not available in this browser!");
        window.alert("Web Bluetooth API is not available in this browser!");
    }
    console.log('The Web Bluetooth API is ready.');
    return true
}

//****** Callback Handlers ********

/* onDisconnected callback
   Ideally, this callback would execute when the ESP32 disconnects or
   looses power.  In practice, however, that doesn't happen.  Not sure
   it's doing us any good at all.
*/

function onDisconnected(event){
    console.log('Device Disconnected:', event.target.device.name);
    grnLED.className = "gryled";
    connectToDevice();  // this is common practice but why -- it's
			// going to fail
}

/* toggleRedLED
   Send the command to toggle the Red LED to the ESP32 using BLE Write.
   NB: ledState is sent and toggled after the write. So ledState
   reflects the future state not the present.
*/

function toggleRedLED() {
    if (bleServer && bleServer.connected) {
        bleServiceFound.getCharacteristic(ledAspect)
            .then(characteristic => {
                console.log("Found the LED: ", characteristic.uuid);
                const data = new Uint8Array(Array.from(
		    ledState, char => char.charCodeAt(0)));
                return characteristic.writeValue(data);
            })
            .then(() => {
                console.log("Value written to LED aspect:", ledState);
		if ( ledState == "on" ) {
		    redLED.className = "redled";
		    ledState = "off";
		}
		else {
		    redLED.className = "gryled";
		    ledState = "on";
		}
            })
            .catch(error => {
                console.error("Error writing to the Red LED: ", error);
            });
    } else {
        console.error ("Red LED control failed!  Please connect Bluetooth.")
        window.alert("Red LED control failed!\nPlease connect Bluetooth.")
    }
}

/* writeOnControl

 Send commands and out-of-band control messages to the ESP32 and
 servos.

 The control aspect is separate from the Servo aspect because the
 touch interface will queue up a lot of requests for movement and it
 can take time for the queue to clear. We therefore need an
 "out-of-band" method for stopping the servos.  The writeOnControl
 function used here provides this as well as other control functions
 such as disconnect by reset.

*/

async function writeOnControl(value) {
    if ( bleServer && bleServer.connected ) {
	try {
	    await bleServiceFound.getCharacteristic(controlAspect)
		.then(characteristic => {
		    const data = new Uint8Array(Array.from(
			value, char => char.charCodeAt(0)));
		    return characteristic.writeValue(data);
		});
	}
	catch (error) {
	    // control messages are top priority so retry on failure
	    if ( error.name === 'NetworkError'
	       || error.name === 'NotSupportedError' ) { // if busy, try again
		console.log("busy, trying again");
		await delay(50);
		return writeOnControl(value);
	    }
	    else {
                console.error("writeOnControl: failed with ", error);
            }
	}
    }
    else {
	console.error("ESP32 control failed! Please connect Bluetooth.");
    }
}

/* writeOnServo

   The servoAspect tells the ESP32 to move the motors and the
   direction of movement. We expect this function to produce failures
   because the BLE write queue is easily filled and touch events are
   quickly generated in large numbers. NB: Look carefully, you'll find
   that retries after an error are disabled.

   The format of our messages is dX<space>dY. dX is the direction of
   movement for the X servo and dY is the direction for the Y servo.

   NB: speed is set using writeOnControl.
   
*/
   
async function writeOnServo(value){
    if (bleServer && bleServer.connected) {
	try {
	    // use try/catch to make sure this completes -- retry
            await bleServiceFound.getCharacteristic(servoAspect)
		.then(characteristic => {
                    const data = new Uint8Array(Array.from(
			value, char => char.charCodeAt(0)));
		    return characteristic.writeValue(data);
		});
	}
	catch (error) {
	    if ( error.name === 'NetworkError'
	       || error.name === 'NotSupportedError' ) { // if busy, try again
		console.log("busy, trying again");
		await delay(50);
		return writeOnServo(value);
	    }
	    else {
                console.error("Error writing to the Servo: ", error);
            }
	}
    } else {
        console.error ("writeOnServo: Bluetooth not connected!");
        window.alert("Unable to move Servos! Please connect Bluetooth.");
    }
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function sleep(milliseconds) {
    var start = new Date().getTime();
    while ( true ) {
	if ((new Date().getTime() - start) > milliseconds){
	    break;
	}
    }
}

let lastDX, lastDY;  
let lastX, lastY;
const fuzz = 20; // reduces the resolution of the touch area

document.querySelector('.dot').addEventListener('touchstart',
						TStart, {passive: false});
document.querySelector('.dot').addEventListener('touchend',
						TStart, {passive: false});
document.querySelector('.dot').addEventListener('touchmove',
						TStart, {passive: false});
function TStart(ev) {
    ev.preventDefault();
    console.log(ev.touches, ev.type);
    if ( ev.type == 'touchstart' ) { // reset our starting point
	// everything is relative to that
	lastX = Math.floor(ev.touches[0].clientX / fuzz);
	lastY = Math.floor(ev.touches[0].clientY / fuzz);
	writeOnControl("START");
	console.log("START");
    }
    else if ( ev.type == 'touchmove' ) {
	let dX = 0;
	let dY = 0;
	let x = Math.floor(ev.touches[0].clientX / fuzz);
	let y = Math.floor(ev.touches[0].clientY / fuzz);

	if ( x != lastX )
	    dX = x > lastX ? 1 : -1;
	if ( y != lastY )
	    dY = y > lastY ? 1 : -1;

	if ( dX != lastDX || dY != lastDY ) {
	    var msg = dX.toString() + " " + dY.toString();
	    writeOnServo(msg);
	    lastDX = dX;
	    lastDY = dY;
	    lastX = x;
	    lastY = y;
	    console.log("sent " + msg);
	}
    }
    else if ( ev.type == 'touchend' ) {
	delay(50);
	writeOnControl("STOP");
    }
}

// start things off by connecting to the ESP32 over BLE
var bluetoothDevice;

async function connectToDevice() {
    if ( bluetoothDevice && bluetoothDevice.gatt.connected ) {
	console.log("Already connected.");
	return;
    }
    try {
	await navigator.bluetooth.requestDevice({
	    filters: [{name: deviceName}],
	    optionalServices: [bleService]
	})
	// act on the promise object returned
	    .then(device => {
		console.log('Got device:', device.name);
		grnLED.className = 'grnled';
		device.addEventListener('gattservicedisconnected',
					onDisconnected);
		bluetoothDevice = device;
		return device.gatt.connect();
	    })
	    .then(gattServer => {
		bleServer = gattServer;
		console.log("GATT Server connected.");
		return bleServer.getPrimaryService(bleService);
	    })
	    .then(service => {
		bleServiceFound = service;
		console.log('Service discovered:', service.uuid);
		return service.getCharacteristic(statusAspect);
	    })
	    .then(characteristic => {
		activeStatusAspect = characteristic;
		sleep(100);
		return characteristic.readValue();
	    })
            .then(value => {
		const decodedValue = new TextDecoder().decode(value);
		console.log("Decoded value: ", decodedValue);
		servoStatus.innerHTML = "connected";
		enableUpdates = true;
            })
	    .catch(error => {
		console.log('Error: ', error);
	    });
    }
    catch (error) {
	console.error('Connection error:', error);
    }
}

window.addEventListener('beforeunload', () => {
    disconnectDevice();
});

window.onload = initialValues;
function initialValues() {
    // led state
    ledState = "on";
    redLED.className = "gryled";
    grnLED.className = "gryled";
    
    // initial slider states
    xspdValue.innerHTML = "5";
    yspdValue.innerHTML = "5";
    xspdSlider.value = 5;
    yspdSlider.value = 5;
    servoStatus.innerHTML = "disconnected";
    enableUpdates = false;
    setInterval(getServoStatus, 1000);
}

/* getServoStatus
   We poll the status because notify stopped working after a Chrome update.
*/

function getServoStatus() {
    if ( enableUpdates && bleServer && bleServer.connected ) {
	if ( activeStatusAspect ) {
	    activeStatusAspect.readValue()
		.then(v => {
		    const value = new TextDecoder().decode(v);
		    servoStatus.innerHTML = value;
		});
	}
    }
}

function disconnectDevice() {
    console.log("Disconnect Device.");
    if (bleServer && bleServer.connected) {
	enableUpdates = false;
    } else {
        // Throw an error if Bluetooth is not connected
        console.error("Bluetooth is not connected.");
        window.alert("Bluetooth is not connected.")
    }
}

</script>

</html>

